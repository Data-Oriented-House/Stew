[{"title":"Factory","type":0,"sectionRef":"#","url":"/Stew/api/Factory","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Factory","url":"/Stew/api/Factory#functions","content":" "},{"title":"add​","type":1,"pageTitle":"Factory","url":"/Stew/api/Factory#add","content":"&lt;/&gt; Factory.add( entity: any, ...: any ) → Component Adds the factory's type of component to the entity. If the component already exists, it just returns the old component and does not perform any further changes. Anything can be an Entity, if an unregistered object is given a component it is registered as an entity. Fires the world and factory added callbacks. local World = require(path.to.world) local Move = require(path.to.move.factory) local Chase = require(path.to.chase.factory) local Model = require(path.to.model.factory) local enemy = World.entity() Model.add(enemy) Move.add(enemy) Chase.add(enemy) -- continues to below example   "},{"title":"remove​","type":1,"pageTitle":"Factory","url":"/Stew/api/Factory#remove","content":"&lt;/&gt; Factory.remove( entity: any, ...: any ) → void? Removes the factory's type of component from the entity. If the entity is unregistered, nothing happens. Fires the world and factory removed callbacks. -- continued from above example task.wait(5) Chase.remove(entity) Move.remove(entity)  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/Stew/docs/Installation","content":"","keywords":""},{"title":"Manually​","type":1,"pageTitle":"Installation","url":"/Stew/docs/Installation#manually","content":"Just copy the source code from src/init.lua and call it a day. "},{"title":"Wally Package Manager​","type":1,"pageTitle":"Installation","url":"/Stew/docs/Installation#wally-package-manager","content":"Visit wally Type Stew in the search bar and select data-oriented-house/stew Click the text under Install on the right-hand side to copy the most recent version In your project go to your wally.toml file and paste this under Dependencies "},{"title":"Stew","type":0,"sectionRef":"#","url":"/Stew/api/Stew","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#functions","content":" "},{"title":"world​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#world","content":"&lt;/&gt; Stew.world() → World "},{"title":"Types","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew##","content":""},{"title":"​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#World","content":"interface World { added: ( factory: Factory, entity: any, component: any ) removed: ( factory: Factory, entity: any, component: any ) spawned: (entity: any) → () killed: (entity: any) → () built: (archetype: Archetype) → () }  Creates a new world. -- Your very own world to toy with local myWorld = Stew.world() -- If you'd like to listen for certain events, you can define these callbacks: -- Called whenever a new factory is built function myWorld.built(archetype: Archetype) end -- Called whenever a new entity is registered function myWorld.spawned(entity) end -- Called whenever an entity is unregistered function myWorld.killed(entity) end -- Called whenever an entity recieves a component function myWorld.added(factory, entity, component) end -- Called whenever an entity loses a component function myWorld.removed(factory, entity, component) end  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/Stew/docs/intro","content":"","keywords":""},{"title":"Some Notes​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#some-notes","content":"Stew is a very templated piece of software regarding data formats, allowing for things most others won't. This extends Stew's usefulness as a behavior-implementation and state-management solution. The internals of Stew are volatile and expected to change, potentially rapidly. "},{"title":"Style​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#style","content":"Style was chosen to be concise, easy to type, and easy to read. Please feel no pressure to use Stew conventions in your own code if undesired. "},{"title":"No Dependencies; Self Contained​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#no-dependencies-self-contained","content":"Stew commits to not depending on resources outside of its own ecosystem, this leads to interesting design consequences. In place of events where you may connect and listen for things to happen, Stew provides defineable callbacks that can execute arbitrary code at any of these stages. This allows any user to use their own event implementation such as Sleitnick's Signal or Roblox's BindableEvent. It even allows the freedom to debug the entirety of all stew operations, and potentially build tooling to beautifly view Stew internals at runtime. "},{"title":"Respecting The User​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#respecting-the-user","content":"Stew respects your intelligence, needs, and desires, trusting you with how you want to use it. It wants to be integratable into a codebase of any style. As a consequence of this, it provides a different set of tools compared to other ECS-like projects. The implementation is aimed to be as generic as possible, allowing you maximum flexibility over data representation, logic execution, implementation details, etc. This is why private fields are prefixed with _ rather than being kept local to the module; if you know what you are doing, you may have at the internals as you please. "},{"title":"DIY-Friendly Instructions; Batteries Not Included​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#diy-friendly-instructions-batteries-not-included","content":"Because of Stew's design philosophy it does not come with many of the bells and whistles of larger-scale competitors. This may be a turn-off for some people, and that's ok! Instead of coming with a way to do every little thing, it gives you the tools to be as flexible as possible while documenting how maintainers and other users have solved common problems. This way if you don't feel like doing it yourself, you can look up the code for it and call it a day! Backend And Ecosystem Contributor​ This is a great incentive to build upon Stew, either with packages or wrappers; if you find Stew to be lacking and are interested in developing your own ECS, Stew provides an amazing backend to, spice things up, and get your project out sooner without the hassle of archetypal memory management! "},{"title":"Lexicon","type":0,"sectionRef":"#","url":"/Stew/docs/Lexicon","content":"","keywords":""},{"title":"What is an Entity?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-an-entity","content":"An entity is a unique identifier used to relate components together. They represent a single thing in your world. In lua this is trivial with the efficient implementations of hash maps. Because of this superpower, anything that can be hashed can be used as an entity, and in lua that's basically everything. So in short, entities can be anything as long as they are unique. "},{"title":"What is a Component?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-component","content":"A component is a fundamental unit of data. Components are used to represent instantiable state. Each entity will have its own set of components. The combination of components simulates an implicit type that can change at runtime. By creating and deleting components, you can take advantage of dynamic runtime polymorphism. For more information about polymorphism and its usecases, refer to online resources. Keep in mind that polymorphism extends far beyond object-oriented programming, and is a fundamental concept in mathematics and computer-science. "},{"title":"What does it mean to be Dynamic?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-does-it-mean-to-be-dynamic","content":"This means changeable, or not static / constant. "},{"title":"What does it mean to be during Runtime?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-does-it-mean-to-be-during-runtime","content":"This means as the program runs, not during compilation or before. "},{"title":"What is a System?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-system","content":"A system is a transform that operates on a set of entities with certain components. "},{"title":"What is a Transform?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-transform","content":"This is a procedure that takes in a certain number of inputs, processes them, and potentially returns a certain number of outputs. More information can be found in the Data Oriented Design book by Richard Fabian. "},{"title":"What is a World?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-world","content":"A world is an instantiable container for all entities, components, and other state. You create entities and components in worlds, and you can create different components in different worlds. For example, your server and clients will always have different worlds. "},{"title":"World","type":0,"sectionRef":"#","url":"/Stew/api/World","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"World","url":"/Stew/api/World#types","content":" "},{"title":"Archetype​","type":1,"pageTitle":"World","url":"/Stew/api/World#Archetype","content":"&lt;/&gt; interface Archetype { factory: Factory&lt;E,C,A...,R...&gt;, create: ( factory, entity: E, A... ) → C, delete: ( factory, entity: E, component: C, R... ) → () signature: string, }   "},{"title":"FactoryArgs​","type":1,"pageTitle":"World","url":"/Stew/api/World#FactoryArgs","content":"&lt;/&gt; interface FactoryArgs { add: ( factory: Factory, entity: E, A... ) → C remove: ( factory: Factory, entity: E, component: C, R... ) → ()? }   "},{"title":"Components​","type":1,"pageTitle":"World","url":"/Stew/api/World#Components","content":"&lt;/&gt; type Components = {[Factory]: Component}  "},{"title":"Functions​","type":1,"pageTitle":"World","url":"/Stew/api/World#functions","content":" "},{"title":"factory​","type":1,"pageTitle":"World","url":"/Stew/api/World#factory","content":"&lt;/&gt; World.factory(factoryArgs: FactoryArgs) → Factory Creates a new factory from an add constructor and optional remove destructor. local world = Stew.world() local position = world.factory { add = function(factory, entity: any, x: number, y: number, z: number) return Vector3.new(x, y, z) end, } local body = world.factory { add = function(factory, entity: Instance, model: Model) model.Parent = entity return model end, remove = function(factory, entity: Instance, component: Model) component:Destroy() end, } -- If you'd like to listen for interesting events to happen, define these callbacks: -- Called when an entity recieves this factory's component function body.added(entity: Instance, component: Model) end -- Called when an entity loses this factory's component function body.removed(entity: Instance, component: Model) end   "},{"title":"tag​","type":1,"pageTitle":"World","url":"/Stew/api/World#tag","content":"&lt;/&gt; World.tag() → Factory Syntax sugar for defining a factory that adds a true component. It is used to mark the existence of the component, like a tag does. local world = Stew.world() local sad = world.tag() local happy = world.tag() local sleeping = world.tag() local poisoned = world.tag() local allHappyPoisonedSleepers = world.query { happy, poisoned, sleeping }   "},{"title":"entity​","type":1,"pageTitle":"World","url":"/Stew/api/World#entity","content":"&lt;/&gt; World.entity() → Entity Creates an arbitrary entity and registers it. Keep in mind, in Stew, anything can be an Entity (except nil). If you don't have a pre-existing object to use as an entity, this will create a unique identifier you can use. Cannot be sent over remotes. (If this is a feature you believe would be beneficial, make an issue in the repository for it!) Fires the world spawned callback. local World = require(path.to.world) local Move = require(path.to.move.factory) local Chase = require(path.to.chase.factory) local Model = require(path.to.model.factory) local enemy = World.entity() Model.add(enemy) Move.add(enemy) Chase.add(enemy) -- continues to below example   "},{"title":"kill​","type":1,"pageTitle":"World","url":"/Stew/api/World#kill","content":"&lt;/&gt; World.kill( entity: Entity, ...: any ) → () Removes all components from an entity and unregisters it. Fires the world killed callback. -- continued from above example task.wait(5) World.kill(enemy)   "},{"title":"get​","type":1,"pageTitle":"World","url":"/Stew/api/World#get","content":"Do Not Modify &lt;/&gt; World.get(entity: Entity) → Components Gets all components of an entity in a neat table you can iterate over. This is a reference to the internal representation, so mutating this table directly will cause Stew to be out-of-sync. local World = require(path.to.world) local Move = require(path.to.move.factory) local Chase = require(path.to.chase.factory) local Model = require(path.to.model.factory) local enemy = World.entity() Model.add(enemy) local components = world.get(enemy) for factory, component in components do print(factory, component) end -- Model, Model Move.add(enemy) for factory, component in components do print(factory, component) end -- Model, Model -- Move, BodyMover Chase.add(enemy) for factory, component in components do print(factory, component) end -- Model, Model -- Move, BodyMover -- Chase, TargetInstance print(world.get(entity)[Chase]) -- TargetInstance   "},{"title":"query​","type":1,"pageTitle":"World","url":"/Stew/api/World#query","content":"Do Not Modify &lt;/&gt; World.query(factories: {Factory}) → {[Entity]: Components} Gets a set of all entities that have at least the queried components. (This is the magic sauce of it all!) This is a reference to the internal representation, so mutating this table directly will cause Stew to be out-of-sync. local World = require(path.to.world) local Poisoned = require(path.to.poisoned.factory) local Health = require(path.to.health.factory) local Color = require(path.to.color.factory) local poisonedHealths = world.query { Poisoned, Health } -- This is a very cool system RunService.Heartbeat:Connect(function(deltaTime) for entity, components in poisonedHealths do local health = components[Health] local poison = components[Poison] health.current -= deltaTime * poison if health.current &lt; 0 then World.kill(entity) end end end) -- This is another very cool system RunService.RenderStepped:Connect(function(deltaTime) for entity, components in world.query { Poisoned, Color } do local color = components[Color] color.hue += deltaTime * (120 - color.hue) color.saturation += deltaTime * (1 - color.saturation) end end)  "},{"title":"Common Patterns","type":0,"sectionRef":"#","url":"/Stew/docs/Common Patterns","content":"","keywords":""},{"title":"Deferred Execution​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#deferred-execution","content":"Sometimes you may find yourself needing to execute code after the constructor or other callback fires. To do this, and to not do more than you have to, you can use the factory's added callback. local world = Stew.world() local myComponent = world.factory { added = function(factory, entity) print(&quot;Before&quot;) return true end, } function myComponent.added(entity, component) print(&quot;After&quot;) end  "},{"title":"Modularity + Event Decoupling​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#modularity--event-decoupling","content":"More often than not you will want to separate code execution from where it is being called, so you do not couple unrelated or modular code. Stew provides component-level and world-level ways to achieve this, both along the same lines and very simple. Since arbitrary code can be executed whenever a component is constructed, events of your choice can be fired. This also ties well into using Module Scripts when defining Worlds or Components, since you can easily define extra data alongside everything else and encourage more flexible data accessing. It pairs well with the idea of registries, modules of purely constant data. local Module = {} Module.signals = { built = Instance.new 'BindableEvent', added = Instance.new 'BindableEvent', } Module.world = Stew.world() function Module.world.built(archetype) -- oooooh fancy under-the-hood stuffffffffff Module.signals.built:Fire(archetype.signature) end function Module.world.added(factory, entity, component) Module.signals.added:Fire(factory, entity, component) end return Module  local World = require(path.to.module).world local Module = {} Module.signals = { added = Instance.new 'BindableEvent', removed = Instance.new 'BindableEvent', } Module.factory = World.factory { added = function(factory, entity: Player, x: number, y: number) return x + y end, } export type Component = typeof(Module.factory.add(...)) function Module.factory.added(entity: Player, component: Component) Module.signals.added:Fire(entity, component) end function Module.factory.removed(entity: Player, component: Component) Module.signals.removed:Fire(entity, component) end return Module  "},{"title":"System Scheduling​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#system-scheduling","content":"Systems are just functions, and typically they run on a certain schedule. RunService tends to do the trick here, but you can use whatever you want. Often we may need systems to run in a certain order, so we start by centralizing this logic in a single place. -- System1.lua return function(deltaTime) ... end -- System2.lua return function(deltaTime) ... end -- System3.lua return function(deltaTime) ... end -- System4.lua return function(deltaTime) ... end -- Main.server.lua local System1 = require(path.to.System1) local System2 = require(path.to.System2) local System3 = require(path.to.System3) local System4 = require(path.to.System4) RunService.Heartbeat:Connect(function(deltaTime) System2(deltaTime) System4(deltaTime) System1(deltaTime) System3(deltaTime) end)  However, this is both not very flexible and hard to maintain. We can't infer which systems depend on which, and we can't easily add or remove systems without coming back to this file. We can solve these by first inverting the relationship of each system to the event. -- System1.server.lua RunService.Heartbeat:Connect(function(deltaTime) ... end) -- System2.server.lua RunService.Heartbeat:Connect(function(deltaTime) ... end) -- System3.server.lua RunService.Heartbeat:Connect(function(deltaTime) ... end) -- System4.server.lua RunService.Heartbeat:Connect(function(deltaTime) ... end)  Now we can add new systems without having to go back to the main file (there is no main file!). This process can be generalized to a technique called Dependency Inversion. But now they aren't ordered! They have to be ordered or it breaks! We can solve this by using a signal implementation that is ordered. Priorities aren't a good idea here, like what RunService's RenderStepped provides, because they aren't flexible and don't tell us what depends on what. For this, we'll want to use Topological Sorting. We can use this lightweight ordered signal implementation called Sandwich to replace Heartbeat. -- Schedules.lua local Sandwich = require(path.to.Sandwich) return { heartbeat = Sandwich.schedule(), } -- System1.lua local System2 = require(path.to.System2) return Schedules.heartbeat.job(function(deltaTime) ... end, System2) -- System2.lua return Schedules.heartbeat.job(function(deltaTime) ... end) -- System3.lua local System1 = require(path.to.System1) return Schedules.heartbeat.job(function(deltaTime) ... end, System1) -- System4.lua local System2 = require(path.to.System2) return Schedules.heartbeat.job(function(deltaTime) ... end, System2) -- Main.server.lua RunService.Heartbeat:Connect(Schedules.heartbeat.start)  And now we clearly see System1 and System4 depend on System2, and System3 depends on System1. This will force us to think about our systems and how they interact with each other, and force us to not design cyclical systems. "},{"title":"Reactive Components​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#reactive-components","content":"Sometimes we really want to know when components change. We get these benefits from ValueBase instances like NumberValues, ObjectValues, or the OSS variants like Observables. Anything can be a component in Stew, there's nothing stopping you from using these as components. Let's use the TableValue library to implement reactive tables with a similar api to ValueBase instances. local World = require(path.to.World) local TableValue = require(path.to.TableValue) local MovementBoost = World.factory { add = function(factory, entity: Humanoid, speedMultiplier: number, jumpMultiplier: number) local self = { old = { WalkSpeed = entity.WalkSpeed, JumpPower = entity.JumpPower, }, multipliers = TableValue.new {}, } -- Very fun stuff! This will update our humanoid whenever we add a field function self.multipliers.Changed(property: string, value: number) entity[property] = value * self.old[property] end -- Add the fields (one by one so they can be automatically updated (exciting!)) self.multipliers.WalkSpeed = speedMultiplier self.multipliers.JumpPower = jumpMultiplier return self end, remove = function(factory, entity: Humanoid, self) entity.WalkSpeed = self.old.Walkspeed entity.JumpPower = self.old.JumpPower end, } return MovementBoost  "},{"title":"Instances As Entities​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#instances-as-entities","content":"There are many cases you'll want to use an Instance as an Entity, such as the Player, Character, monster model, etc. Stew allows this, but does not clean up components if the instance is destroyed (the instance still exists anyways!). To implement this, we can take advantage of the world spawned callback. local world = Stew.world() local connections = {} function world.spawned(entity) if typeof(entity) == &quot;Instance&quot; then connections[entity] = entity.Destroyed:Once(function() world.kill(entity) end) end end function world.killed(entity) if typeof(entity) == &quot;Instance&quot; then connections[entity]:Disconnect() connections[entity] = nil end end  "},{"title":"CollectionService Integration​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#collectionservice-integration","content":"CollectionService is a powerful tool and useful for tag replication. We can use our factory callbacks to integrate with it. local world = Stew.world() -- We could use a normal factory, -- but since CollectionService tags only exist to be added and removed, -- they can't have any data anyways, so we'll use a tag instead. local poisoned = world.tag() function poisoned.added(entity: Instance) entity:AddTag 'Poisoned' end function poisoned.removed(entity: Instance) entity:RemoveTag 'Poisoned' end CollectionService:GetInstanceAddedSignal('Poisoned'):Connect(world.factory.add) CollectionService:GetInstanceRemovedSignal('Poisoned'):Connect(world.factory.remove)  Notice we have to come up with a new string for each tag. This is because CollectionService uses strings to identify tags while Stew uses factories. If you'd like, you can keep a registry mapping factories to names, but unless everything is centralized beforehand this can be a pain to maintain. "},{"title":"Replication​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#replication","content":"Replication is a very complex topic, and Stew does not provide any replication out of the box because there are so many ways it can be done optimally. However, it does provide a very powerful foundation to build upon. The following is a very simple example of how you could implement replication. First we need to understand the problem. We need to selectively copy the state of one world to another. Worse, these worlds are separated across the client/server boundary and can't communicate with each other directly. Let's tackle these one at a time, and work on a case-by-case basis. To begin, we allow ourself to make the assumption world1 exists before world2. Any connections world1 performs will have happened before world2 is created. This is a reasonable assumption mimicking server/client relationships. (These code examples have not been tested and here solely for educational purposes) "},{"title":"Tag Callbacks​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#tag-callbacks","content":"local world1 = Stew.world() local tag1 = world1.tag()  local world2 = Stew.world() local tag2 = world2.tag() function tag1.added(entity) tag2.add(entity) end function tag1.removed(entity) tag2.remove(entity) end  Pros: Entities can be anythingDead simple to setup and maintainConcise and scalable Cons: Only works for tagsOnly works for this componentCan't do anything more with tag1's callbacksCouples the two worlds together and their factories directlyDoesn't account for entities that were added before the tag was created "},{"title":"Tag Signals​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#tag-signals","content":"To decouple the two worlds, we can use signals. local world1 = Stew.world() local tag1 = world1.tag() local tagAdded = Instance.new 'BindableEvent' local tagRemoved = Instance.new 'BindableEvent' function tag1.added(entity) tagAdded:Fire(entity) end function tag1.removed(entity) tagRemoved:Fire(entity) end  local world2 = Stew.world() local tag2 = world2.tag() tagAdded.Event:Connect(tag2.add) tagRemoved.Event:Connect(tag2.remove)  Pros: Entities can be anythingDecouples the two worldsCan do more with tag1's callbacksStill concise Cons: Only works for tagsOnly works for this componentDoesn't account for entities that were added before the tag was createdNot as scalable "},{"title":"Tag Signals + Entity Fetching​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#tag-signals--entity-fetching","content":"The only way we can guarantee that we get all the initial entities is by asking for them when ready. local askForAllTag1 = Instance.new 'BindableEvent' local giveAllTag1 = Instance.new 'BindableEvent'  local world1 = Stew.world() local tag1 = world1.tag() local tagAdded = Instance.new 'BindableEvent' local tagRemoved = Instance.new 'BindableEvent' function tag1.added(entity) tagAdded:Fire(entity) end function tag1.removed(entity) tagRemoved:Fire(entity) end askForAllTag1.Event:Connect(function() local tagged = world1.query { tag1 } local list = {} for entity in entities do table.insert(list, entity) end giveAllTag1:Fire(list) end)  local world2 = Stew.world() local tag2 = world2.tag() tagAdded.Event:Connect(tag2.add) tagRemoved.Event:Connect(tag2.remove) giveAllTag1.Event:Connect(function(entities) for _, entity in entities do tag2.add(entity) end end) askForAllTag1:Fire()  Pros: Entities can be anythingDecouples the two worldsCan do more with tag1's callbacksAccounts for entities that were added before the tag was created Cons: Only works for tagsOnly works for this componentLosing conciseness and scalability "},{"title":"Factory Signals + Entity Fetching​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#factory-signals--entity-fetching","content":"To make this work for more than just tags, we need factories. However, now our components actually have data, and have to be reconstructed on the other side. This is where we get the decision to couple the worlds again by reducing the amount of data we send, or decouple the worlds and send all the data. For networking we typically assume we only have two worlds and must minimize the amount of data we send as much as possible. For scalability, we want to decouple any worlds as much as possible, implying we send all the data. Mix and match as you see fit. It is up to you to decide which is best for your usecase. local askForAllComponent1 = Instance.new 'BindableEvent' local giveAllComponent1 = Instance.new 'BindableEvent'  local ReactiveTable = require(path.to.reactiveTable) -- hypothetical implementation local world1 = Stew.world() local componentAdded = Instance.new 'BindableEvent' local componentRemoved = Instance.new 'BindableEvent' local componentChanged = Instance.new 'BindableEvent' local component1 = world1.factory { added = function(factory, entity, name: string, height: number, occupation: string) local self = ReactiveTable.wrap { name = name, height = height, occupation = occupation, } self.Value.changed = self.Changed:Connect(function(key, value) componentChanged:Fire(entity, key, value) end) return self end, removed = function(factory, entity, self) self.Value.changed:Disconnect() end, } function component1.added(entity, component) componentAdded:Fire(entity, component) end function component1.removed(entity, component) componentRemoved:Fire(entity) end askForAllComponent1.Event:Connect(function() local queried = world1.query { component1 } local list = {} for entity in entities do list[entity] = world.get(entity)[component1] end giveAllComponent1:Fire(list) end)  local world2 = Stew.world() local component2 = world2.factory { added = function(factory, entity, height: number, occupation: string) return { height = height, occupation = occupation, } end, } componentAdded.Event:Connect(component2.add) componentRemoved.Event:Connect(component2.remove) componentChanged.Event:Connect(function(entity, key, value) local component = world2.get(entity)[component2] if key == 'height' or key == 'occupation' then component[key] = value end end) giveAllComponent1.Event:Connect(function(entities) for entity, component in entities do component2.add(entity, component.height, component.occupation) end end) askForAllComponent1:Fire()  Pros: Entities can be anythingWorks for any component typeDecouples the two worldsAccounts for entities that were added before the tag was created Cons: Only works for this componentReally losing conciseness and scalability "},{"title":"Centralized Signals + Entity Fetching​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#centralized-signals--entity-fetching","content":"To fix the scalability issue, we can centralize everything into a &quot;Replication&quot; system. This centralized system will be responsible for all replication. Since this is centralized, we will inevitably start coupling other factories to this system to map the factories to names and from names to factories again. We can use this to our advantage though, and maintain our selective capabilities like before. Only certain factories will replicate. We now face another issue, how do we know when to replicate? We want to replicate when a component changes, meaning we need to keep track of that somehow. A reactive table library like TableValue allows you to run code when changes to tables occur. To comply with this, we can no longer use any data type we want, and must use tables to support indirections. local Module = {} Module.askForAll = Instance.new 'BindableEvent' Module.giveAll = Instance.new 'BindableEvent' Module.update = Instance.new 'BindableEvent' return Module  local World1 = require(path.to.World1) local Module = {} Module.factoriesToNames = { [require(path.to.component1.factory)] = 'a', -- strings save the most space, [require(path.to.component2.factory)] = 'b', -- consider automating this process [require(path.to.component4.tag)] = 'c', -- with a compression library like Squash } local Replicate = World1.factory { added = function(factory, entity) return {} end, } Module.factory = Replicate -- This would be called whenever we want to enqueue the current state of a component -- to be replicated, which can be automated if using a reactive table library. We can -- listen for when the table changes and call this, leaving it out-of-mind and out-of-sight. function Module.enqueue(entity, factory) local name = Module.factoriesToNames[factory] assert(name, 'Factory cannot be replicated!') local replicate = Replicate.add(entity) -- If it doesn't exist then it will be created else it will be returned local other = World1.get(entity)[factory] assert(other, `Entity does not have a {name} factory component`) replicate[name] = other end return Module  local World1 = require(path.to.World1) local Replicate = require(path.to.Replicate.factory).factory local Signals = require(path.to.Signals) -- This is the centralized system, it is responsible for all replication -- You can consider decreasing the frequency of this system for performance reasons RunService.Heartbeat:Connect(function(deltaTime) local payload = {} for entity, components in World1.query { Replicate } do payload[entity] = components[Replicate] Replicate.remove(entity) end Signals.update:Fire(payload) end) Signals.askForAll.Event:Connect(function() local payload = {} for entity, components in World1.query {} do -- queries for all entities in the world local replicate = {} for factory, name in Replicate.factoriesToNames do replicate[name] = components[factory] end if next(replicate) then payload[entity] = replicate end end Signals.giveAll:Fire(payload) end)  Then on one of the receiving ends: local World2 = require(path.to.World2) local Signals = require(path.to.Signals) -- These are responsible for taking the recieved component data and somehow -- mapping it to the new components, either by mutating or adding a new component to the entity local namesToMaps = {} function namesToMaps['a'](entity, component1) local Component5 = require(path.to.component5.factory) -- requires moved inside for demo only ... end function namesToMaps['b'](entity, component2) local Component9 = require(path.to.component9.factory) ... end function namesToMaps['c'](entity, component4) local Component8 = require(path.to.component8.factory) ... end local function handlePayload(payload) for entity, replicate in payload do for name, component in replicate do local map = namesToMaps[name] assert(map, `A {name} map does not exist on the receiving end!`) map(entity, component) end end end Signals.update:Connect(handlePayload) Signals.giveAll:Once(handlePayload) Signals.askForAll:Fire()  Pros: Entities can be anythingWorks for any component typeWorks for all componentsDecouples the two worldsAccounts for entities that were added before the tag was created Cons: Can't make enough assumptions to optimizeThis is a nontrivial section of the codebase now "},{"title":"Final Notes​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#final-notes","content":"Clearly there are a lot of ways one can engineer replication. Aim for the simplest solution and don't try to overcomplicate it. Think about what will be most ergonomic to work with, maintain, and extend upon and roll with it. If you can't decide, try the simplest approach until you figure out what needs to be more complicated. "}]