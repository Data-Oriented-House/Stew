[{"title":"World","type":0,"sectionRef":"#","url":"/Stew/api/World","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"World","url":"/Stew/api/World#functions","content":" "},{"title":"Create​","type":1,"pageTitle":"World","url":"/Stew/api/World#Create","content":"&lt;/&gt; World.Create(WorldArgs: WorldArgs?) → World Creates a new world, and for convenience creates all methods that pass a world as the first argument in it, too "},{"title":"Collection","type":0,"sectionRef":"#","url":"/Stew/api/Collection","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Collection","url":"/Stew/api/Collection#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"Collection","url":"/Stew/api/Collection#Get","content":"Read Only &lt;/&gt; Collection.Get( Names: {Name}-- An array of component names. ) → Collection-- Returns a collection of all entities that have all the components specified. Used to get all entities with certain components. This is useful for implementing systems. It is a reference rather than a copy, so it is read-only and automatically updates when entities are created or deleted. local World = Stew.World.Create() World.Component.Build(&quot;Starving&quot;) World.Component.Build(&quot;Health&quot;, { Constructor = function(Entity : Stew.Entity&lt;any&gt;, Name : string) return { Current = 100; Max = 100; } end; }) local Hurting : Stew.Collection = World.Collection.Get{&quot;Health&quot;, &quot;Starving&quot;} RunService.Heartbeat:Connect(function(DeltaTime : number) for Entity in Hurting do local Health = Stew.Component.Get(Entity, &quot;Health&quot;) Health.Current -= DeltaTime end end)  "},{"title":"Errors","type":1,"pageTitle":"Collection","url":"/Stew/api/Collection##","content":"Type\tDescriptionComponent Not Built\tA component with the given name is not built.  "},{"title":"GetFirst​","type":1,"pageTitle":"Collection","url":"/Stew/api/Collection#GetFirst","content":"&lt;/&gt; Collection.GetFirst( Names: {Name}-- An array of component names. ) → Entity?-- Returns the first entity found in a collection. This is useful for systems involving components that only exist in isolation. Order is not guaranteed because this is a set. local World = Stew.World.Create() World.Component.Build(&quot;Selected&quot;, { Constructor = function(Entity : any, Name : string) return { Position = Vector3.new(); Rotation = 0; } end; }) local Part : Part = Instance.new(&quot;Part&quot;) World.Component.Create(Part, &quot;Selected&quot;) local World = require(Path.To.World) local Part : Part = World.Collection.GetFirst{&quot;Selected&quot;} print(Part)  "},{"title":"Errors","type":1,"pageTitle":"Collection","url":"/Stew/api/Collection##","content":"Type\tDescriptionComponent Not Built\tA component with the given name is not built. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/Stew/docs/intro","content":"","keywords":""},{"title":"Some Notes​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#some-notes","content":"Stew is a very templated piece of software regarding data formats, allowing for things most others won't. This extends Stew's usefulness well beyond ECS, as can also easily implement things like Finite State Machines. The internals of Stew are volatile and expected to change, potentially rapidly. "},{"title":"Style​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#style","content":"Though Stew uses PascalCase, semicolon delimiters, and spaces between colons all around, please feel no pressure to use these conventions in your own code. It also experiments with using tables as namespaces, which does lead to nested tables with the benefit of less duplication and language supported organization. Funnily enough, the nested namespaces begin reading like plain english! "},{"title":"No Dependencies; Self Contained​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#no-dependencies-self-contained","content":"Stew commits to not depending on resources outside of its own ecosystem, this leads to interesting design consequences. In place of events where you may connect and listen for things to happen, Stew provides defineable callbacks that can execute arbitrary code at any of these stages. This allows any user to use their own event implementation such as Sleitnick's Signal or Roblox's BindableEvent. It even allows the freedom to debug the entirety of all stew operations, and potentially build tooling to beautifly view Stew internals at runtime. "},{"title":"Respecting The User​","type":1,"pageTitle":"Introduction","url":"/Stew/docs/intro#respecting-the-user","content":"Unlike many OSS projects today, Stew respects your intelligence, needs, and desires, trusting you with how you want to use it. It wants to be integratable into any pre-existing codebase. As a consequence of this, it provides a different set of tools compared to other ECS-like projects. The implementation is aimed to be as generic as possible, allowing you maximum flexibility over data representation, logic execution, implementation details, etc. This is why private fields are prefixed with _ rather than being kept local to the module; if you know what you are doing, you may have at the internals as you please. An example of tooling differences is instead of offering a way to define systems in a scheduler that query certain components, Stew returns references to collections of entities with the specified components, allowing you to iterate or copy these collections as necessary. This is under the motivation that systems are user-defined logic that operate on intersections of entities, that may run on pre-existing scheduling systems, so Stew provides a way to get intersections of entities and nothing more. "},{"title":"Lexicon","type":0,"sectionRef":"#","url":"/Stew/docs/Lexicon","content":"","keywords":""},{"title":"What is an Entity?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-an-entity","content":"An entity is a unique identifier used to access components. They represent a single thing in your world. In lua this is trivial with the efficient implementations of hash maps. Because of this superpower, anything that can be hashed can be used as an entity, and in lua that's basically everything. So in short, entities can be anything as long as they are unique. "},{"title":"What is a Component?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-component","content":"A component is a fundamental unit of data. Components are used to represent instantiable state. Each entity will have its own set of components. The combination of components simulates an implicit type that can change at runtime. By creating and deleting components, you can take advantage of dynamic runtime polymorphism. For more information about polymorphism and its usecases, refer to online resources with the context this was first introduced with Object Oriented Design. "},{"title":"What does it mean to be Dynamic?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-does-it-mean-to-be-dynamic","content":"This means changeable, or not static / constant. "},{"title":"What does it mean to be during Runtime?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-does-it-mean-to-be-during-runtime","content":"This means as the program runs, not during compilation or before. "},{"title":"What is a System?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-system","content":"A system is a transform that operates on a set of entities with certain components. "},{"title":"What is a Transform?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-transform","content":"This is a procedure that takes in a certain number of inputs, processes them, and potentially returns a certain number of outputs. More information can be found in the Data Oriented Design book by Richard Fabian. "},{"title":"What is a World?​","type":1,"pageTitle":"Lexicon","url":"/Stew/docs/Lexicon#what-is-a-world","content":"A world is an instantiable container for all entities, components, and other state. You create entities and components in worlds, and you can create different components in different worlds. Without worlds, Stew would be a singleton which has serious drawbacks and violates the conditions for transforms. "},{"title":"Common Patterns","type":0,"sectionRef":"#","url":"/Stew/docs/Common Patterns","content":"","keywords":""},{"title":"Deferred Execution​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#deferred-execution","content":"Sometimes you may find yourself needing to execute code after the constructor or other callback fires. To do this, and to not do more than you have to, you can use task.defer to execute code the frame after it was called. local World = Stew.World.Create() World.Component.Build(&quot;MyComponent&quot;, { Constructor = function(Entity, Name) print(&quot;Before&quot;) task.defer(function() print(&quot;After&quot;) end) return true end; })  "},{"title":"Modularity + Event Decoupling​","type":1,"pageTitle":"Common Patterns","url":"/Stew/docs/Common Patterns#modularity--event-decoupling","content":"More often than not you will want to separate code execution from where it is being called, so you do not couple unrelated or modular code. Stew provides component-level and world-level ways to achieve this, both along the same lines and very simple. Since arbitrary code can be executed whenever a component is constructed, events of your choice can be fired. This also ties well into using Module Scripts when defining Worlds or Components, since you can easily define extra data alongside everything else and encourage more flexible data accessing. It pairs well with the idea of registries, modules of purely constant data. This particular example uses Sleitnick's Signal implementation. local Module = {} Module.Signals = { Built = Signal.new(); Created = Signal.new(); } Module.World = Stew.World.Create { Component = { Build = function(Name, ComponentData) Module.Signals.Built:Fire(Name, ComponentData.Signature) end; Create = function(Entity, Name, Component) Module.Signal.Created:Fire(Entity, Name, Component) end; }; } return Module  local World = require(Path.To.Module).World local Module = {} Module.Signals = { Created = Signal.new(); Deleted = Signal.new(); } World.Component.Build(&quot;MyComponent&quot;, { Constructor = function(Entity : Player, Name : string, Arg1 : number, Arg2 : number) : number local Component = Arg1 + Arg2 task.defer(function() Module.Signals.Created:Fire(Entity, Name, Component) end) return Component end; Destructor = function(Entity : Player, Name : string) Module.Signals.Deleted:Fire(Entity, Name) end; }) return Module  "},{"title":"Stew","type":0,"sectionRef":"#","url":"/Stew/api/Stew","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#types","content":" "},{"title":"Name​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#Name","content":"&lt;/&gt; type Name = any A name is a unique identifier used as a key to access components of entities.  "},{"title":"Component​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#Component","content":"&lt;/&gt; type Component = any A component is user-defined data that is accessed by an entity. It is defined through the Component.Build function. It is created through the Component.Create function.  "},{"title":"Entity<E>​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#Entity<E>","content":"&lt;/&gt; type Entity&lt;E&gt; = E An entity is a unique identifier used to access components by their names. It is created through the Entity.Create function. The entity's components can be accessed by Component.Get or Component.GetAll.  "},{"title":"Collection​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#Collection","content":"&lt;/&gt; interface Collection { [Entity]: true } A set of entities containing specific components.  "},{"title":"ComponentArgs<E, N, C, D>​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#ComponentArgs<E, N, C, D>","content":"&lt;/&gt; interface ComponentArgs&lt;E, N, C, D&gt; { Constructor: &lt;T...&gt;( Entity: Entity&lt;E&gt;, Name: N, T... ) → C Destructor: &lt;T...&gt;( Entity: Entity&lt;E&gt;, Name: N, T... ) → D } Optional arguments to build a component with the Component.Build function.  "},{"title":"WorldArgs​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#WorldArgs","content":"&lt;/&gt; interface WorldArgs { Component?.Build: (( Name: Name, ComponentData: ComponentData ) → ())? Component?.Create: (( Entity: Entity, Name: Name, Component: Component ) → ())? Component?.Delete: (( Entity: Entity, Name: Name, Deleted: any ) → ())? Entity?.Create: ((Entity: Entity) → ())? Entity?.Delete: ((Entity: Entity) → ())? } Optional arguments to build a component with the Component.Build function. Everything is optional, including the On table.  "},{"title":"World​","type":1,"pageTitle":"Stew","url":"/Stew/api/Stew#World","content":"&lt;/&gt; interface World { Collection.Get: (Names: {Name}) → Collection Collection.GetFirst: (Names: {Name}) → Entity&lt;any&gt; Component.Build: ( Name: Name, ComponentArgs: ComponentArgs? ) → () Component.Create: ( Entity: Entity, Name: Name, ...any ) → Component? Component.Delete: ( Entity: Entity, Name: Name, ...any ) → any? Component.GetAll: (Entity: Entity) → {[Name]: Component} Component.Get: ( Entity: Entity, Name: Name ) → Component? Entity.Create: () → Entity Entity.Delete: (Entity: Entity) → () Entity.Register: (Entity: Entity) → () _NextPlace: number _NameToData: {[Name]: ComponentData} _EntityToData: {[Entity]: EntityData} _SignatureToCollection: {[Signature]: Collection} _Component.Build: ( Name: Name, ComponentData: ComponentData ) → () _Component.Create: ( Entity: Entity, Name: Name, Component: Component ) → () _Component.Delete: ( Entity: Entity, Name: Name, Deleted: any ) → () _Entity.Create: (Entity: Entity) → () _Entity.Delete: (Entity: Entity) → () }  "},{"title":"Entity","type":0,"sectionRef":"#","url":"/Stew/api/Entity","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Entity","url":"/Stew/api/Entity#functions","content":" "},{"title":"Register​","type":1,"pageTitle":"Entity","url":"/Stew/api/Entity#Register","content":"&lt;/&gt; Entity.Register(Entity: any) → () Register an entity with the world. This is done automatically when creating a component. local World = Stew.World.Create() -- They all work! :D World.Entity.Register(5) World.Entity.Register(&quot;Hi&quot;) World.Entity.Register({ Cool = true }) World.Entity.Register(newproxy()) World.Entity.Register(Instance.new(&quot;Part&quot;)) -- No entity left behind!  "},{"title":"Errors","type":1,"pageTitle":"Entity","url":"/Stew/api/Entity##","content":"Type\tDescriptionEntity Registered Twice\tAn entity cannot be registered twice without first being deleted.  "},{"title":"Create​","type":1,"pageTitle":"Entity","url":"/Stew/api/Entity#Create","content":"&lt;/&gt; Entity.Create() → Entity Creates, registers, and returns an entity. Uses newproxy internally, so these entities cannot be sent over the network. local World = Stew.World.Create() local Entity1 : any = World.Entity.Create() print(Entity1) --&gt; userdata   "},{"title":"Delete​","type":1,"pageTitle":"Entity","url":"/Stew/api/Entity#Delete","content":"&lt;/&gt; Entity.Delete(Entity: Entity) → () Deletes all components associated with an entity and removes it from all internal storage. The entity must be registered again to be used, though this is done automatically when creating components. local World = Stew.World.Create() local States = { Happy = 1; Sad = 2; } World.Component.Build(States.Happy) World.Component.Build(States.Sad) local Entity : any = Stew.Entity.Create() World.Component.Create(Entity, States.Happy) World.Component.Create(Entity, States.Sad) print(Stew.Component.GetAll(Entity)) --&gt; { [1] = true, [2] = true } Stew.Entity.Delete(Entity) print(Stew.Component.GetAll(Entity)) --&gt; {}  "},{"title":"Component","type":0,"sectionRef":"#","url":"/Stew/api/Component","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/Stew/api/Component#functions","content":" "},{"title":"Build​","type":1,"pageTitle":"Component","url":"/Stew/api/Component#Build","content":"&lt;/&gt; Component.Build( Name: Name,-- The name of the component. ComponentArgs: ComponentArgs?-- The arguments to build the component ) → () Sets up an internal constructor and destructor for a component. This is used to create and destroy components. If arguments are not provided, an empty table will be used instead. Both the constructor and destructor are optional and can be omitted. If no constructor is specified, a default constructor that returns true is used. If no destructor is specified, a default destructor that does nothing is used. local World = Stew.World.Create() World.Component.Build(&quot;Poisoned&quot;) World.Component.Build(&quot;Health&quot;, { Constructor = function(Entity : any, Name : string, Max : number) return { Current = Max; Max = Max; } end; }) World.Component.Build(&quot;Model&quot;, { Constructor = function(Entity : any, Name : string, Model : Model, NewName : string) local NewModel = Model:Clone() NewModel.Name = NewName return NewModel end; Destructor = function(Entity : any, Name : string) Stew.Component.Get(Entity, Name) :Destroy() end; })  "},{"title":"Errors","type":1,"pageTitle":"Component","url":"/Stew/api/Component##","content":"Type\tDescriptionComponent Built Twice\tA component with the given name has already been built.  "},{"title":"Create​","type":1,"pageTitle":"Component","url":"/Stew/api/Component#Create","content":"&lt;/&gt; Component.Create( Entity: Entity,-- The entity that accesses this component. Name: Name,-- The name of the component to be created. ...: any-- Any additional arguments. ) → Component?-- The component that was created. Creates a unique component associated with the entity and returns it. Automatically registers the entity if it hasn't been registered yet. If the constructor returns void or nil, the component will not be created. local World = Stew.World.Create() World.Component.Build(&quot;Model&quot;, { Constructor = function(Entity : any, Name : string, Model : Model, Allow : boolean) if not Allow then return end return Model:Clone() end; }) local LocalPlayer : Player = Players.LocalPlayer print(World.Component.Get(LocalPlayer, &quot;Model&quot;)) --&gt; nil World.Component.Create(LocalPlayer, &quot;Model&quot;, workspace.CoolModel, false) print(World.Component.Get(LocalPlayer, &quot;Model&quot;)) --&gt; nil World.Component.Create(LocalPlayer, &quot;Model&quot;, workspace.CoolModel, true) print(World.Component.Get(LocalPlayer, &quot;Model&quot;)) --&gt; CoolModel  "},{"title":"Errors","type":1,"pageTitle":"Component","url":"/Stew/api/Component##","content":"Type\tDescriptionComponent Not Built\tA component with the given name is not built.  "},{"title":"Delete​","type":1,"pageTitle":"Component","url":"/Stew/api/Component#Delete","content":"&lt;/&gt; Component.Delete( Entity: Entity,-- The entity to delete the component from. Name: Name,-- The name of the component to be deleted. ...: ...any-- Any additional arguments. ) → () Deletes the component associated with the passed entity. If the destructor returns a truthy value, the component will not be deleted. local World = Stew.World.Create() World.Component.Build(&quot;Model&quot;, { Constructor = function(Entity : any, Name : string, Model : Model) return Model:Clone() end; Destructor = function(Entity : any, Name : string, Allow : boolean) if not Allow then return true end Stew.Component.Get(Entity, Name) :Destroy() end; }) local Part : Part = Instance.new(&quot;Part&quot;) World.Component.Create(Part, &quot;Model&quot;, workspace.CoolModel) print(Stew.Component.Get(Part, &quot;Model&quot;)) --&gt; CoolModel Stew.Component.Delete(Part, &quot;Model&quot;, false) print(Stew.Component.Get(Part, &quot;Model&quot;)) --&gt; CoolModel Stew.Component.Delete(Part, &quot;Model&quot;, true) print(Stew.Component.Get(Part, &quot;Model&quot;)) --&gt; nil  "},{"title":"Errors","type":1,"pageTitle":"Component","url":"/Stew/api/Component##","content":"Type\tDescriptionComponent Not Built\tA component with the given name is not built.  "},{"title":"Get​","type":1,"pageTitle":"Component","url":"/Stew/api/Component#Get","content":"&lt;/&gt; Component.Get( Entity: Entity, Name: Name ) → Component? Gets a component from an entity. local World = Stew.World.Create() World.Component.Build(&quot;Grid&quot;, { Constructor = function(Entity : any, Name : string, Properties: { Dimensions : Vector2; Default : number; }) return { Cells = table.create(Properties.Dimensions.X * Properties.Dimensions.Y, Properties.Default); } end; }) local GridId = 1 local Grid1 = Stew.Component.Get(GridId, &quot;Grid&quot;) print(Grid1) --&gt; nil World.Component.Create(GridId, &quot;Grid&quot;, Vector2.new(10, 10)) local Grid2 = Stew.Component.Get(GridId, &quot;Grid&quot;) print(Grid2) --&gt; CoolModel   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/Stew/api/Component#GetAll","content":"&lt;/&gt; Component.GetAll(Entity: Entity) → {[Name]: Component} Returns a table of all an entity's components in the form of a dictionary. This dictionary is cloned to prevent tampering. local World = Stew.World.Create() World.Component.Build(&quot;Red&quot;) World.Component.Build(&quot;Green&quot;) World.Component.Build(&quot;Blue&quot;, { Constructor = function(Entity : any, Name : string, Value : number) return Value end; }) local Entity = World.Entity.Create() World.Component.Create(Entity, &quot;Red&quot;) World.Component.Create(Entity, &quot;Green&quot;) World.Component.Create(Entity, &quot;Blue&quot;, 5) for Name: string, Component: any in Stew.Component.GetAll(Entity) do print(Name, Component) --[[ Red true Green true Blue 5 ]] end  "}]