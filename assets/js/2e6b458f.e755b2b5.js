"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[170],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=c(t),m=o,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||l;return t?a.createElement(h,i(i({ref:n},d),{},{components:t})):a.createElement(h,i({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=t.length,i=new Array(l);i[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:o,i[1]=r;for(var c=2;c<l;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},59693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const l={sidebar_position:3},i="Common Patterns",r={unversionedId:"Common Patterns",id:"Common Patterns",title:"Common Patterns",description:"As Stew's usage grows, patterns to achieve common tasks make themselves apparent and will find themselves here. These are by no means strict guidelines on how to use Stew, but rather suggestions on how to use it in a way that is more efficient and easier to understand.",source:"@site/docs/Common Patterns.md",sourceDirName:".",slug:"/Common Patterns",permalink:"/Stew/docs/Common Patterns",draft:!1,editUrl:"https://github.com/data-oriented-house/Stew/edit/main/docs/Common Patterns.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Lexicon",permalink:"/Stew/docs/Lexicon"}},s={},c=[{value:"Deferred Execution",id:"deferred-execution",level:2},{value:"Modularity + Event Decoupling",id:"modularity--event-decoupling",level:2},{value:"System Scheduling",id:"system-scheduling",level:2},{value:"Reactive Components",id:"reactive-components",level:2},{value:"Instances As Entities",id:"instances-as-entities",level:2},{value:"CollectionService Integration",id:"collectionservice-integration",level:2},{value:"Replication",id:"replication",level:2},{value:"Tag Callbacks",id:"tag-callbacks",level:3},{value:"Tag Signals",id:"tag-signals",level:3},{value:"Tag Signals + Entity Fetching",id:"tag-signals--entity-fetching",level:3},{value:"Factory Signals + Entity Fetching",id:"factory-signals--entity-fetching",level:3},{value:"Centralized Signals + Entity Fetching",id:"centralized-signals--entity-fetching",level:3},{value:"Final Notes",id:"final-notes",level:3}],d={toc:c},u="wrapper";function p(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"common-patterns"},"Common Patterns"),(0,o.kt)("p",null,"As Stew's usage grows, patterns to achieve common tasks make themselves apparent and will find themselves here. These are by no means strict guidelines on how to use Stew, but rather suggestions on how to use it in a way that is more efficient and easier to understand."),(0,o.kt)("h2",{id:"deferred-execution"},"Deferred Execution"),(0,o.kt)("p",null,"Sometimes you may find yourself needing to execute code ",(0,o.kt)("em",{parentName:"p"},"after")," the constructor or other callback fires. To do this, and to not do more than you have to, you can use the factory's ",(0,o.kt)("inlineCode",{parentName:"p"},"added")," callback."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local world = Stew.world()\n\nlocal myComponent = world.factory {\n    added = function(factory, entity)\n        print("Before")\n        return true\n    end,\n}\n\nfunction myComponent.added(entity, component)\n    print("After")\nend\n')),(0,o.kt)("h2",{id:"modularity--event-decoupling"},"Modularity + Event Decoupling"),(0,o.kt)("p",null,"More often than not you will want to separate code execution from where it is being called, so you do not couple unrelated or modular code. Stew provides component-level and world-level ways to achieve this, both along the same lines and very simple. Since arbitrary code can be executed whenever a component is constructed, events of your choice can be fired."),(0,o.kt)("p",null,"This also ties well into using Module Scripts when defining Worlds or Components, since you can easily define extra data alongside everything else and encourage more flexible data accessing. It pairs well with the idea of registries, modules of purely constant data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local Module = {}\n\nModule.signals = {\n    built = Instance.new 'BindableEvent',\n    added = Instance.new 'BindableEvent',\n}\n\nModule.world = Stew.world()\n\nfunction Module.world.built(archetype)\n    -- oooooh fancy under-the-hood stuffffffffff\n    Module.signals.built:Fire(archetype.signature)\nend\n\nfunction Module.world.added(factory, entity, component)\n    Module.signals.added:Fire(factory, entity, component)\nend\n\nreturn Module\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local World = require(path.to.module).world\n\nlocal Module = {}\n\nModule.signals = {\n    added = Instance.new 'BindableEvent',\n    removed = Instance.new 'BindableEvent',\n}\n\nModule.factory = World.factory {\n    added = function(factory, entity: Player, x: number, y: number)\n        return x + y\n    end,\n}\n\nexport type Component = typeof(Module.factory.add(...))\n\nfunction Module.factory.added(entity: Player, component: Component)\n    Module.signals.added:Fire(entity, component)\nend\n\nfunction Module.factory.removed(entity: Player, component: Component)\n    Module.signals.removed:Fire(entity, component)\nend\n\nreturn Module\n")),(0,o.kt)("h2",{id:"system-scheduling"},"System Scheduling"),(0,o.kt)("p",null,"Systems are just functions, and typically they run on a certain schedule. RunService tends to do the trick here, but you can use whatever you want. Often we may need systems to run in a certain order, so we start by centralizing this logic in a single place."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"-- System1.lua\nreturn function(deltaTime) ... end\n\n-- System2.lua\nreturn function(deltaTime) ... end\n\n-- System3.lua\nreturn function(deltaTime) ... end\n\n-- System4.lua\nreturn function(deltaTime) ... end\n\n-- Main.server.lua\nlocal System1 = require(path.to.System1)\nlocal System2 = require(path.to.System2)\nlocal System3 = require(path.to.System3)\nlocal System4 = require(path.to.System4)\n\nRunService.Heartbeat:Connect(function(deltaTime)\n    System2(deltaTime)\n    System4(deltaTime)\n    System1(deltaTime)\n    System3(deltaTime)\nend)\n")),(0,o.kt)("p",null,"However, this is both not very flexible and hard to maintain. We can't infer which systems depend on which, and we can't easily add or remove systems without coming back to this file. We can solve these by first inverting the relationship of each system to the event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"-- System1.server.lua\nRunService.Heartbeat:Connect(function(deltaTime) ... end)\n\n-- System2.server.lua\nRunService.Heartbeat:Connect(function(deltaTime) ... end)\n\n-- System3.server.lua\nRunService.Heartbeat:Connect(function(deltaTime) ... end)\n\n-- System4.server.lua\nRunService.Heartbeat:Connect(function(deltaTime) ... end)\n")),(0,o.kt)("p",null,"Now we can add new systems without having to go back to the main file (there is no main file!). This process can be generalized to a technique called Dependency Inversion. But now they aren't ordered! They have to be ordered or it breaks! We can solve this by using a signal implementation that is ordered. Priorities aren't a good idea here, like what RunService's RenderStepped provides, because they aren't flexible and don't tell us what depends on what. For this, we'll want to use ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Topological_sorting"},"Topological Sorting"),". We can use this lightweight ordered signal implementation called ",(0,o.kt)("a",{parentName:"p",href:"https://data-oriented-house.github.io/Sandwich/"},"Sandwich")," to replace Heartbeat."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"-- Schedules.lua\nlocal Sandwich = require(path.to.Sandwich)\nreturn {\n    heartbeat = Sandwich.schedule(),\n}\n\n-- System1.lua\nlocal System2 = require(path.to.System2)\nreturn Schedules.heartbeat.job(function(deltaTime) ... end, System2)\n\n-- System2.lua\nreturn Schedules.heartbeat.job(function(deltaTime) ... end)\n\n-- System3.lua\nlocal System1 = require(path.to.System1)\nreturn Schedules.heartbeat.job(function(deltaTime) ... end, System1)\n\n-- System4.lua\nlocal System2 = require(path.to.System2)\nreturn Schedules.heartbeat.job(function(deltaTime) ... end, System2)\n\n-- Main.server.lua\nRunService.Heartbeat:Connect(Schedules.heartbeat.start)\n")),(0,o.kt)("p",null,"And now we clearly see System1 and System4 depend on System2, and System3 depends on System1. This will force us to think about our systems and how they interact with each other, and force us to not design cyclical systems."),(0,o.kt)("h2",{id:"reactive-components"},"Reactive Components"),(0,o.kt)("p",null,"Sometimes we really want to know when components ",(0,o.kt)("em",{parentName:"p"},"change"),". We get these benefits from ValueBase instances like NumberValues, ObjectValues, or the OSS variants like Observables. Anything can be a component in Stew, ",(0,o.kt)("em",{parentName:"p"},"there's nothing stopping you from using these as components.")," Let's use the ",(0,o.kt)("a",{parentName:"p",href:"https://data-oriented-house.github.io/TableValue/"},"TableValue")," library to implement reactive tables with a similar api to ValueBase instances."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local World = require(path.to.World)\nlocal TableValue = require(path.to.TableValue)\n\nlocal MovementBoost = World.factory {\n    add = function(factory, entity: Humanoid, speedMultiplier: number, jumpMultiplier: number)\n        local self = {\n            old = {\n                WalkSpeed = entity.WalkSpeed,\n                JumpPower = entity.JumpPower,\n            },\n            multipliers = TableValue.new {},\n        }\n\n        -- Very fun stuff! This will update our humanoid whenever we add a field\n        function self.multipliers.Changed(property: string, value: number)\n            entity[property] = value * self.old[property]\n        end\n\n        -- Add the fields (one by one so they can be automatically updated (exciting!))\n        self.multipliers.WalkSpeed = speedMultiplier\n        self.multipliers.JumpPower = jumpMultiplier\n\n        return self\n    end,\n\n    remove = function(factory, entity: Humanoid, self)\n        entity.WalkSpeed = self.old.Walkspeed\n        entity.JumpPower = self.old.JumpPower\n    end,\n}\n\nreturn MovementBoost\n")),(0,o.kt)("h2",{id:"instances-as-entities"},"Instances As Entities"),(0,o.kt)("p",null,"There are many cases you'll want to use an Instance as an Entity, such as the Player, Character, monster model, etc. Stew allows this, but does not clean up components if the instance is destroyed (the instance still exists anyways!). To implement this, we can take advantage of the world ",(0,o.kt)("inlineCode",{parentName:"p"},"spawned")," callback."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local world = Stew.world()\n\nlocal connections = {}\n\nfunction world.spawned(entity)\n    if typeof(entity) == "Instance" then\n        connections[entity] = entity.Destroyed:Once(function()\n            world.kill(entity)\n        end)\n    end\nend\n\nfunction world.killed(entity)\n    if typeof(entity) == "Instance" then\n        connections[entity]:Disconnect()\n        connections[entity] = nil\n    end\nend\n')),(0,o.kt)("h2",{id:"collectionservice-integration"},"CollectionService Integration"),(0,o.kt)("p",null,"CollectionService is a powerful tool and useful for tag replication. We can use our factory callbacks to integrate with it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world = Stew.world()\n\n-- We could use a normal factory,\n-- but since CollectionService tags only exist to be added and removed,\n-- they can't have any data anyways, so we'll use a tag instead.\nlocal poisoned = world.tag()\n\nfunction poisoned.added(entity: Instance)\n    entity:AddTag 'Poisoned'\nend\n\nfunction poisoned.removed(entity: Instance)\n    entity:RemoveTag 'Poisoned'\nend\n\nCollectionService:GetInstanceAddedSignal('Poisoned'):Connect(world.factory.add)\nCollectionService:GetInstanceRemovedSignal('Poisoned'):Connect(world.factory.remove)\n")),(0,o.kt)("p",null,"Notice we have to come up with a new string for each tag. This is because CollectionService uses strings to identify tags while Stew uses factories. If you'd like, you can keep a registry mapping factories to names, but unless everything is centralized beforehand this can be a pain to maintain."),(0,o.kt)("h2",{id:"replication"},"Replication"),(0,o.kt)("p",null,"Replication is a very complex topic, and Stew does not provide any replication out of the box because there are so many ways it can be done optimally. However, it does provide a very powerful foundation to build upon. The following is a very simple example of how you could implement replication."),(0,o.kt)("p",null,"First we need to understand the problem. We need to selectively copy the state of one world to another. Worse, these worlds are separated across the client/server boundary and can't communicate with each other directly. Let's tackle these one at a time, and work on a case-by-case basis."),(0,o.kt)("p",null,"To begin, we allow ourself to make the assumption world1 exists before world2. Any connections world1 performs will have happened before world2 is created. This is a reasonable assumption mimicking server/client relationships."),(0,o.kt)("p",null,"(",(0,o.kt)("em",{parentName:"p"},"These code examples have not been tested and here solely for educational purposes"),")"),(0,o.kt)("h3",{id:"tag-callbacks"},"Tag Callbacks"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world1 = Stew.world()\nlocal tag1 = world1.tag()\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world2 = Stew.world()\nlocal tag2 = world2.tag()\n\nfunction tag1.added(entity)\n    tag2.add(entity)\nend\n\nfunction tag1.removed(entity)\n    tag2.remove(entity)\nend\n")),(0,o.kt)("p",null,"Pros:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entities can be anything"),(0,o.kt)("li",{parentName:"ul"},"Dead simple to setup and maintain"),(0,o.kt)("li",{parentName:"ul"},"Concise and scalable")),(0,o.kt)("p",null,"Cons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Only works for tags"),(0,o.kt)("li",{parentName:"ul"},"Only works for this component"),(0,o.kt)("li",{parentName:"ul"},"Can't do anything more with tag1's callbacks"),(0,o.kt)("li",{parentName:"ul"},"Couples the two worlds together and their factories directly"),(0,o.kt)("li",{parentName:"ul"},"Doesn't account for entities that were added before the tag was created")),(0,o.kt)("h3",{id:"tag-signals"},"Tag Signals"),(0,o.kt)("p",null,"To decouple the two worlds, we can use signals."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world1 = Stew.world()\nlocal tag1 = world1.tag()\n\nlocal tagAdded = Instance.new 'BindableEvent'\nlocal tagRemoved = Instance.new 'BindableEvent'\n\nfunction tag1.added(entity)\n    tagAdded:Fire(entity)\nend\n\nfunction tag1.removed(entity)\n    tagRemoved:Fire(entity)\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world2 = Stew.world()\nlocal tag2 = world2.tag()\n\ntagAdded.Event:Connect(tag2.add)\ntagRemoved.Event:Connect(tag2.remove)\n")),(0,o.kt)("p",null,"Pros:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entities can be anything"),(0,o.kt)("li",{parentName:"ul"},"Decouples the two worlds"),(0,o.kt)("li",{parentName:"ul"},"Can do more with tag1's callbacks"),(0,o.kt)("li",{parentName:"ul"},"Still concise")),(0,o.kt)("p",null,"Cons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Only works for tags"),(0,o.kt)("li",{parentName:"ul"},"Only works for this component"),(0,o.kt)("li",{parentName:"ul"},"Doesn't account for entities that were added before the tag was created"),(0,o.kt)("li",{parentName:"ul"},"Not as scalable")),(0,o.kt)("h3",{id:"tag-signals--entity-fetching"},"Tag Signals + Entity Fetching"),(0,o.kt)("p",null,"The only way we can guarantee that we get all the initial entities is by asking for them when ready."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local askForAllTag1 = Instance.new 'BindableEvent'\nlocal giveAllTag1 = Instance.new 'BindableEvent'\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world1 = Stew.world()\nlocal tag1 = world1.tag()\n\nlocal tagAdded = Instance.new 'BindableEvent'\nlocal tagRemoved = Instance.new 'BindableEvent'\n\nfunction tag1.added(entity)\n    tagAdded:Fire(entity)\nend\n\nfunction tag1.removed(entity)\n    tagRemoved:Fire(entity)\nend\n\naskForAllTag1.Event:Connect(function()\n    local tagged = world1.query { tag1 }\n\n    local list = {}\n    for entity in tagged do\n        table.insert(list, entity)\n    end\n\n    giveAllTag1:Fire(list)\nend)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world2 = Stew.world()\nlocal tag2 = world2.tag()\n\ntagAdded.Event:Connect(tag2.add)\ntagRemoved.Event:Connect(tag2.remove)\n\ngiveAllTag1.Event:Connect(function(entities)\n    for _, entity in entities do\n        tag2.add(entity)\n    end\nend)\n\naskForAllTag1:Fire()\n")),(0,o.kt)("p",null,"Pros:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entities can be anything"),(0,o.kt)("li",{parentName:"ul"},"Decouples the two worlds"),(0,o.kt)("li",{parentName:"ul"},"Can do more with tag1's callbacks"),(0,o.kt)("li",{parentName:"ul"},"Accounts for entities that were added before the tag was created")),(0,o.kt)("p",null,"Cons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Only works for tags"),(0,o.kt)("li",{parentName:"ul"},"Only works for this component"),(0,o.kt)("li",{parentName:"ul"},"Losing conciseness and scalability")),(0,o.kt)("h3",{id:"factory-signals--entity-fetching"},"Factory Signals + Entity Fetching"),(0,o.kt)("p",null,"To make this work for more than just tags, we need factories. However, now our components actually have data, and have to be reconstructed on the other side. This is where we get the decision to couple the worlds again by reducing the amount of data we send, or decouple the worlds and send all the data. For networking we typically assume we only have two worlds and must minimize the amount of data we send as much as possible. For scalability, we want to decouple any worlds as much as possible, implying we send all the data. Mix and match as you see fit. It is up to you to decide which is best for your usecase."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local askForAllComponent1 = Instance.new 'BindableEvent'\nlocal giveAllComponent1 = Instance.new 'BindableEvent'\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local ReactiveTable = require(path.to.reactiveTable) -- hypothetical implementation\nlocal world1 = Stew.world()\n\nlocal componentAdded = Instance.new 'BindableEvent'\nlocal componentRemoved = Instance.new 'BindableEvent'\nlocal componentChanged = Instance.new 'BindableEvent'\n\nlocal component1 = world1.factory {\n    added = function(factory, entity, name: string, height: number, occupation: string)\n        local self = ReactiveTable.wrap {\n            name = name,\n            height = height,\n            occupation = occupation,\n        }\n\n        self.Value.changed = self.Changed:Connect(function(key, value)\n            componentChanged:Fire(entity, key, value)\n        end)\n\n        return self\n    end,\n\n    removed = function(factory, entity, self)\n        self.Value.changed:Disconnect()\n    end,\n}\n\nfunction component1.added(entity, component)\n    componentAdded:Fire(entity, component)\nend\n\nfunction component1.removed(entity, component)\n    componentRemoved:Fire(entity)\nend\n\naskForAllComponent1.Event:Connect(function()\n    local queried = world1.query { component1 }\n\n    local list = {}\n    for entity in queried do\n        list[entity] = component1.get(entity)\n    end\n\n    giveAllComponent1:Fire(list)\nend)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local world2 = Stew.world()\n\nlocal component2 = world2.factory {\n    added = function(factory, entity, height: number, occupation: string)\n        return {\n            height = height,\n            occupation = occupation,\n        }\n    end,\n}\n\ncomponentAdded.Event:Connect(component2.add)\ncomponentRemoved.Event:Connect(component2.remove)\n\ncomponentChanged.Event:Connect(function(entity, key, value)\n    local component = component2.get(entity)\n    if key == 'height' or key == 'occupation' then\n        component[key] = value\n    end\nend)\n\ngiveAllComponent1.Event:Connect(function(entities)\n    for entity, component in entities do\n        component2.add(entity, component.height, component.occupation)\n    end\nend)\n\naskForAllComponent1:Fire()\n")),(0,o.kt)("p",null,"Pros:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entities can be anything"),(0,o.kt)("li",{parentName:"ul"},"Works for any component type"),(0,o.kt)("li",{parentName:"ul"},"Decouples the two worlds"),(0,o.kt)("li",{parentName:"ul"},"Accounts for entities that were added before the tag was created")),(0,o.kt)("p",null,"Cons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Only works for this component"),(0,o.kt)("li",{parentName:"ul"},"Really losing conciseness and scalability")),(0,o.kt)("h3",{id:"centralized-signals--entity-fetching"},"Centralized Signals + Entity Fetching"),(0,o.kt)("p",null,'To fix the scalability issue, we can centralize everything into a "Replication" system. This centralized system will be responsible for all replication. Since this is centralized, we will inevitably start coupling other factories to this system to map the factories to names and from names to factories again. We can use this to our advantage though, and maintain our ',(0,o.kt)("em",{parentName:"p"},"selective")," capabilities like before. Only certain factories will replicate."),(0,o.kt)("p",null,"We now face another issue, how do we know when to replicate? We want to replicate when a component changes, meaning we need to keep track of that somehow. A reactive table library like ",(0,o.kt)("a",{parentName:"p",href:"https://data-oriented-house.github.io/TableValue/"},"TableValue")," allows you to run code when changes to tables occur. To comply with this, we can no longer use any data type we want, and must use tables to support indirections."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local Module = {}\n\nModule.askForAll = Instance.new 'BindableEvent'\nModule.giveAll = Instance.new 'BindableEvent'\nModule.update = Instance.new 'BindableEvent'\n\nreturn Module\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local World1 = require(path.to.World1)\n\nlocal Module = {}\n\nModule.factoriesToNames = {\n    [require(path.to.component1.factory)] = 'a', -- strings save the most space,\n    [require(path.to.component2.factory)] = 'b', -- consider automating this process\n    [require(path.to.component4.tag)]     = 'c', -- with a compression library like Squash\n}\n\nlocal Replicate = World1.factory {\n    added = function(factory, entity)\n        return {}\n    end,\n}\n\nModule.factory = Replicate\n\n-- This would be called whenever we want to enqueue the current state of a component\n-- to be replicated, which can be automated if using a reactive table library. We can\n-- listen for when the table changes and call this, leaving it out-of-mind and out-of-sight.\nfunction Module.enqueue(entity, factory)\n    local name = Module.factoriesToNames[factory]\n    assert(name, 'Factory cannot be replicated!')\n\n    local replicate = Replicate.add(entity) -- If it doesn't exist then it will be created else it will be returned\n\n    local other = factory.get(entity)\n    assert(other, `Entity does not have a {name} factory component`)\n\n    replicate[name] = other\nend\n\nreturn Module\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local World1 = require(path.to.World1)\nlocal Replicate = require(path.to.Replicate.factory).factory\nlocal Signals = require(path.to.Signals)\n\n-- This is the centralized system, it is responsible for all replication\n-- You can consider decreasing the frequency of this system for performance reasons\nRunService.Heartbeat:Connect(function(deltaTime)\n    local payload = {}\n    for entity, components in World1.query { Replicate } do\n        payload[entity] = components[Replicate]\n        Replicate.remove(entity)\n    end\n    Signals.update:Fire(payload)\nend)\n\nSignals.askForAll.Event:Connect(function()\n    local payload = {}\n    for entity, components in World1.query {} do -- queries for all entities in the world\n        local replicate = {}\n\n        for factory, name in Replicate.factoriesToNames do\n            replicate[name] = components[factory]\n        end\n\n        if next(replicate) then\n            payload[entity] = replicate\n        end\n    end\n    Signals.giveAll:Fire(payload)\nend)\n")),(0,o.kt)("p",null,"Then on one of the receiving ends:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local World2 = require(path.to.World2)\nlocal Signals = require(path.to.Signals)\n\n-- These are responsible for taking the recieved component data and somehow\n-- mapping it to the new components, either by mutating or adding a new component to the entity\nlocal namesToMaps = {}\n\nfunction namesToMaps['a'](entity, component1)\n    local Component5 = require(path.to.component5.factory) -- requires moved inside for demo only\n    ...\nend\n\nfunction namesToMaps['b'](entity, component2)\n    local Component9 = require(path.to.component9.factory)\n    ...\nend\n\nfunction namesToMaps['c'](entity, component4)\n    local Component8 = require(path.to.component8.factory)\n    ...\nend\n\nlocal function handlePayload(payload)\n    for entity, replicate in payload do\n        for name, component in replicate do\n            local map = namesToMaps[name]\n            assert(map, `A {name} map does not exist on the receiving end!`)\n\n            map(entity, component)\n        end\n    end\nend\n\nSignals.update:Connect(handlePayload)\n\nSignals.giveAll:Once(handlePayload)\nSignals.askForAll:Fire()\n")),(0,o.kt)("p",null,"Pros:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entities can be anything"),(0,o.kt)("li",{parentName:"ul"},"Works for any component shape"),(0,o.kt)("li",{parentName:"ul"},"Works for all components"),(0,o.kt)("li",{parentName:"ul"},"Decouples the two worlds"),(0,o.kt)("li",{parentName:"ul"},"Accounts for entities that were added before the tag was created")),(0,o.kt)("p",null,"Cons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Can't make enough assumptions to optimize"),(0,o.kt)("li",{parentName:"ul"},"This is a nontrivial section of the codebase now")),(0,o.kt)("h3",{id:"final-notes"},"Final Notes"),(0,o.kt)("p",null,"Clearly there are a lot of ways one can engineer replication. Aim for the simplest solution and don't try to overcomplicate it. Think about what will be most ergonomic to work with, maintain, and extend upon and roll with it. If you can't decide, try the simplest approach until you figure out what needs to be more complicated."))}p.isMDXComponent=!0}}]);